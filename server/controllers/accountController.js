// server\controllers\accountController.js (FINAL CORRECTED VERSION)
const mongoose = require('mongoose');
const Account = require('../models/Account');
const Transaction = require('../models/Transaction'); // Will be used for checks
const Loan = require('../models/Loan'); // Will be used for checks
const Settings = require('../models/Settings'); // Import Settings model directly
const Constants = require('../utils/constants'); // Import constants

const asyncHandler = require('../middleware/asyncHandler');
const { ErrorResponse } = require('../utils');

// Helper to get currency from settings (centralized and cached for efficiency)
let appSettingsCache = null; // Cache the settings once loaded

async function getCurrency() {
  if (!appSettingsCache) {
    appSettingsCache = await Settings.findOne({ settingsId: 'app_settings' });
    if (!appSettingsCache) {
      console.warn(`Settings document not found. Using default currency ${Constants.DEFAULT_CURRENCY}.`);
      appSettingsCache = { general: { currency: Constants.DEFAULT_CURRENCY } }; // Fallback
    }
  }
  return appSettingsCache.general?.currency || Constants.FALLBACK_CURRENCY; // Ensure default if general is missing
}

// @desc    Create a new account
// @route   POST /api/accounts
// @access  Private (Admin, Officer) - via authorize middleware
exports.createAccount = asyncHandler(async (req, res, next) => {
  // Removed 'accountNumber' from destructuring, as it's generated by the model's pre-save hook
  const { owner, ownerModel, type, status, name, description } = req.body;

  // Basic validation
  if (!owner || !ownerModel || !type) {
    return next(
      new ErrorResponse('Owner, ownerModel, and type are required.', 400)
    );
  }
  if (!mongoose.Types.ObjectId.isValid(owner)) {
    return next(new ErrorResponse('Invalid owner ID format.', 400));
  }
  if (!['User', 'Group'].includes(ownerModel)) {
    return next(
      new ErrorResponse('ownerModel must be "User" or "Group".', 400)
    );
  }
  if (
    !['savings', 'loan_fund', 'operating_expense', 'revenue'].includes(type)
  ) {
    return next(new ErrorResponse('Invalid account type.', 400));
  }

  // Check if an account of this type already exists for the owner
  // This check is also handled by the unique composite index in the Account model
  const existingAccount = await Account.findOne({ owner, ownerModel, type });
  if (existingAccount) {
    return next(
      new ErrorResponse(
        `An account of type '${type}' already exists for this ${ownerModel}.`,
        400
      )
    );
  }

  const account = await Account.create({
    owner,
    ownerModel,
    type,
    // accountNumber will be generated by the pre-save hook in the model if not provided
    status: status || 'active', // Default to active
    balance: 0, // Always start at 0, balance changes via transactions
    name, // Add name field
    description, // Add description field
  });

  // Populate for response
  // Assuming 'groupName' is a virtual or field on Group model, adjust if needed
  await account.populate('owner', 'name email');

  const formattedAccount = account.toObject({ virtuals: true });
  // Call the virtual getter
  formattedAccount.formattedBalance = await account.formattedBalance;

  res.status(201).json({
    success: true,
    message: 'Account created successfully.',
    data: formattedAccount,
  });
});

// @desc    Get all accounts (filtered by role via middleware)
// @route   GET /api/accounts
// @access  Private (filterDataByRole middleware handles access)
exports.getAccounts = asyncHandler(async (req, res, next) => {
  // Base filter from role-based middleware
  const roleFilter = req.dataFilter || {};

  // Build query filters from request query params
  const { type, ownerModel, owner, status, search, sortBy, sortOrder } =
    req.query || {};
  const queryFilters = {};

  if (type) {
    queryFilters.type = type;
  }
  if (ownerModel) {
    queryFilters.ownerModel = ownerModel;
  }
  if (owner) {
    if (!mongoose.Types.ObjectId.isValid(owner)) {
      return next(new ErrorResponse('Invalid owner ID format.', 400));
    }
    queryFilters.owner = owner;
  }
  if (status) {
    queryFilters.status = status;
  }
  if (search) {
    // Match by accountNumber or name (if present) using case-insensitive regex
    const regex = new RegExp(search, 'i');
    queryFilters.$or = [{ accountNumber: regex }, { name: regex }];
  }

  // Merge role filter and query filters
  const finalFilter = Object.keys(roleFilter).length
    ? { $and: [roleFilter, queryFilters] }
    : queryFilters;

  // Sorting options
  const sortField = sortBy || 'createdAt';
  const sortDirection = sortOrder === 'asc' ? 1 : -1;
  const sortSpec = { [sortField]: sortDirection };

  const accounts = await Account.find(finalFilter)
    .populate('owner', 'name email')
    .sort(sortSpec);

  // Await async virtuals for formatting
  const formattedAccounts = await Promise.all(
    accounts.map(async acc => {
      const obj = acc.toObject({ virtuals: true });
      obj.formattedBalance = await acc.formattedBalance;
      return obj;
    })
  );

  res.status(200).json({
    success: true,
    count: formattedAccounts.length,
    data: formattedAccounts,
  });
});

// @desc    Get a single account by ID
// @route   GET /api/accounts/:id
// @access  Private (authorizeOwnerOrAdmin middleware handles access)
exports.getAccountById = asyncHandler(async (req, res, next) => {
  const { id } = req.params;

  if (!mongoose.Types.ObjectId.isValid(id)) {
    return next(new ErrorResponse('Invalid account ID format.', 400));
  }

  // const currency = await getCurrency(); // Not directly needed here, virtual handles it

  // Query will be filtered by authorizeOwnerOrAdmin if implemented via findOne
  const account = await Account.findById(id).populate('owner', 'name email'); // Populate owner details

  if (!account) {
    return next(
      new ErrorResponse('Account not found or you do not have access.', 404)
    );
  }

  const formattedAccount = account.toObject({ virtuals: true });
  formattedAccount.formattedBalance = await account.formattedBalance;

  res.status(200).json({
    success: true,
    data: formattedAccount,
  });
});

// @desc    Update account metadata (NOT balance or type)
// @route   PUT /api/accounts/:id
// @access  Private (Admin, Officer, or Group Leader for group accounts) - via authorize middleware
exports.updateAccount = asyncHandler(async (req, res, next) => {
  const { id } = req.params;
  // Use 'name' from schema, not 'accountName'
  const { status, description, name } = req.body; // Allowed fields to update

  if (!mongoose.Types.ObjectId.isValid(id)) {
    return next(new ErrorResponse('Invalid account ID format.', 400));
  }

  const account = await Account.findById(id);

  if (!account) {
    return next(new ErrorResponse('Account not found.', 404));
  }

  // Prevent direct modification of balance, owner, ownerModel, accountNumber, type
  const forbiddenUpdates = [
    'balance',
    'owner',
    'ownerModel',
    'accountNumber',
    'type',
  ];
  const receivedUpdates = Object.keys(req.body);
  const attemptedForbiddenUpdates = receivedUpdates.filter(field =>
    forbiddenUpdates.includes(field)
  );

  if (attemptedForbiddenUpdates.length > 0) {
    return next(
      new ErrorResponse(
        `Cannot directly update fields: ${attemptedForbiddenUpdates.join(', ')}. Balance changes via transactions only.`,
        400
      )
    );
  }

  // Apply allowed updates
  if (status !== undefined) {
    // Valid statuses from Account model enum (including 'closed')
    const validStatuses = ['active', 'inactive', 'suspended', 'closed'];
    if (!validStatuses.includes(status)) {
      return next(
        new ErrorResponse(
          `Invalid status provided. Must be one of: ${validStatuses.join(', ')}.`,
          400
        )
      );
    }
    account.status = status;
  }
  // Enable updates for 'description' and 'name' fields
  if (description !== undefined) account.description = description;
  if (name !== undefined) account.name = name;

  await account.save();

  // Populate for response
  await account.populate('owner', 'name email');

  const formattedAccount = account.toObject({ virtuals: true });
  formattedAccount.formattedBalance = await account.formattedBalance;

  res.status(200).json({
    success: true,
    message: 'Account metadata updated successfully.',
    data: formattedAccount,
  });
});

// @desc    Delete an account (soft delete recommended)
// @route   DELETE /api/accounts/:id
// @access  Private (Admin only) - via authorize middleware
exports.deleteAccount = asyncHandler(async (req, res, next) => {
  const { id } = req.params;

  if (!mongoose.Types.ObjectId.isValid(id)) {
    return next(new ErrorResponse('Invalid account ID format.', 400));
  }

  const account = await Account.findById(id);

  if (!account) {
    return next(new ErrorResponse('Account not found.', 404));
  }

  // **CRITICAL FINANCIAL INTEGRITY CHECKS**
  // 1. Cannot delete an account with a non-zero balance
  if (account.balance !== 0) {
    return next(
      new ErrorResponse(
        'Cannot delete an account with a non-zero balance. Transfer funds out first.',
        400
      )
    );
  }

  // 2. Cannot delete an account if it's tied to active loans (e.g., loan_fund)
  const activeLoans = await Loan.countDocuments({
    $or: [
      { loanAccount: account._id }, // If this account is the source/destination of loans
      { repaymentAccount: account._id }, // If this account is for repayments
    ],
    status: { $in: ['pending', 'approved', 'disbursed', 'active'] }, // Active loan statuses
  });
  if (activeLoans > 0) {
    return next(
      new ErrorResponse(
        'Cannot delete account with active or pending loans associated with it.',
        400
      )
    );
  }

  // Implement soft delete instead of hard delete for auditability
  account.status = 'closed'; // Set status to 'closed'
  account.deleted = true;
  account.deletedAt = new Date();
  account.deletedBy = req.user.id; // Record who deleted it
  await account.save();

  res.status(200).json({
    success: true,
    message: 'Account successfully marked as closed/deleted.',
    data: {},
  });
});
